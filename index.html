<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>PRICE_LIST</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Nanum+Gothic:wght@400;700;800&display=swap" rel="stylesheet">
<style>
* {
box-sizing: border-box;
margin: 0;
padding: 0;
font-family: 'Nanum Gothic', sans-serif;
}

body {
background-color: #f5f5f5;
padding: 20px;
}

.container {
max-width: 1200px;
margin: 0 auto;
background-color: white;
border-radius: 8px;
box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
padding: 20px;
}

h1 {
text-align: center;
margin-bottom: 25px;
color: #2c3e50;
font-size: 32px;
font-weight: 800;
letter-spacing: -0.5px;
}

/* ê³µí†µ ì—…ë¡œë“œ ì„¹ì…˜ ìŠ¤íƒ€ì¼ */
.common-upload-section {
margin-bottom: 25px;
padding: 20px;
background: linear-gradient(135deg, #6c757d 0%, #5a6268 100%);
border-radius: 12px;
box-shadow: 0 4px 15px rgba(108, 117, 125, 0.2);
}

/* íƒ­ ìŠ¤íƒ€ì¼ */
.tabs {
display: flex;
border-bottom: none;
margin-bottom: 25px;
gap: 10px;
justify-content: center;
}

.tab {
padding: 14px 40px;
background-color: #fff;
border: 2px solid #e0e0e0;
border-radius: 50px;
cursor: pointer;
font-size: 16px;
font-weight: 700;
color: #666;
transition: all 0.3s ease;
box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
}

.tab:hover {
background-color: #f8f9fa;
border-color: #6c757d;
transform: translateY(-2px);
box-shadow: 0 4px 12px rgba(108, 117, 125, 0.15);
}

.tab.active {
background: linear-gradient(135deg, #6c757d 0%, #5a6268 100%);
color: white;
border-color: transparent;
box-shadow: 0 4px 15px rgba(108, 117, 125, 0.3);
transform: translateY(-2px);
}

.tab-content {
display: none;
}

.tab-content.active {
display: block;
}

.upload-area {
text-align: center;
padding: 30px 20px;
cursor: pointer;
transition: all 0.3s ease;
min-height: 140px;
display: flex;
align-items: center;
justify-content: center;
background-color: rgba(255, 255, 255, 0.95);
border-radius: 8px;
border: 2px dashed rgba(255, 255, 255, 0.5);
}

.upload-area:hover {
background-color: rgba(255, 255, 255, 1);
border-color: rgba(255, 255, 255, 0.8);
transform: scale(1.02);
box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
}

.upload-area i {
font-size: 48px;
margin-bottom: 12px;
filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.1));
}

.upload-area h3 {
font-size: 18px;
margin-bottom: 8px;
color: #2c3e50;
font-weight: 700;
}

.upload-area p {
font-size: 14px;
margin: 5px 0;
color: #555;
}

.file-input {
display: none;
}

.file-info {
margin-top: 10px;
font-size: 14px;
color: #666;
}

.db-info {
margin-top: 15px;
padding: 15px;
background-color: rgba(255, 255, 255, 0.95);
border-radius: 8px;
display: none;
font-size: 14px;
border-left: 4px solid #4caf50;
box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
}

.db-info h4 {
margin-bottom: 8px;
color: #2c3e50;
font-size: 16px;
font-weight: 700;
display: flex;
align-items: center;
gap: 8px;
}

.db-info h4:before {
content: "âœ“";
display: inline-block;
width: 24px;
height: 24px;
background: #4caf50;
color: white;
border-radius: 50%;
text-align: center;
line-height: 24px;
font-size: 14px;
}

.db-info p {
margin: 6px 0;
font-size: 13px;
color: #555;
padding-left: 32px;
}

.search-form {
display: grid;
grid-template-columns: repeat(5, 1fr);
gap: 15px 20px;
margin-bottom: 25px;
padding: 25px;
background: #f8f9fa;
border-radius: 12px;
display: none;
box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06);
border: 1px solid #dee2e6;
}

.form-group {
display: flex;
flex-direction: column;
}

label {
margin-bottom: 6px;
font-weight: 700;
color: #2c3e50;
font-size: 14px;
display: flex;
align-items: center;
gap: 6px;
}

label:before {
content: "â–¸";
color: #6c757d;
font-size: 12px;
}

.field-note {
font-size: 11px;
color: #666;
margin-top: 3px;
margin-bottom: 6px;
font-style: normal;
background-color: rgba(255, 255, 255, 0.5);
padding: 4px 8px;
border-radius: 4px;
}

select {
padding: 10px 12px;
border: 2px solid #e0e0e0;
border-radius: 8px;
font-size: 14px;
background-color: white;
cursor: pointer;
transition: all 0.3s ease;
font-weight: 500;
}

select:hover {
border-color: #6c757d;
box-shadow: 0 2px 8px rgba(108, 117, 125, 0.1);
}

select:focus {
outline: none;
border-color: #6c757d;
box-shadow: 0 0 0 3px rgba(108, 117, 125, 0.08);
}

.buttons {
display: flex;
justify-content: center;
gap: 10px;
margin-top: 20px;
grid-column: 1 / -1;
}

button {
padding: 12px 32px;
background: linear-gradient(135deg, #6c757d 0%, #5a6268 100%);
color: white;
border: none;
border-radius: 8px;
cursor: pointer;
font-weight: 700;
font-size: 15px;
transition: all 0.3s ease;
box-shadow: 0 2px 8px rgba(108, 117, 125, 0.2);
}

button:hover {
transform: translateY(-2px);
box-shadow: 0 4px 12px rgba(108, 117, 125, 0.3);
}

button:active {
transform: translateY(0);
}

.reset-btn {
background: linear-gradient(135deg, #adb5bd 0%, #868e96 100%);
box-shadow: 0 2px 8px rgba(173, 181, 189, 0.2);
}

.reset-btn:hover {
box-shadow: 0 4px 12px rgba(173, 181, 189, 0.3);
}

.results {
margin-top: 25px;
}

.results h2 {
color: #2c3e50;
font-size: 22px;
font-weight: 800;
margin-bottom: 15px;
padding-bottom: 10px;
border-bottom: 3px solid #6c757d;
display: inline-block;
}

.sort-controls {
display: flex;
justify-content: flex-end;
align-items: center;
margin-bottom: 15px;
gap: 12px;
padding: 12px;
background-color: #f8f9fa;
border-radius: 8px;
}

.sort-controls label {
font-size: 14px;
color: #2c3e50;
font-weight: 700;
}

.sort-controls select {
padding: 8px 16px;
border: 2px solid #e0e0e0;
border-radius: 8px;
font-size: 14px;
cursor: pointer;
font-weight: 500;
background-color: white;
transition: all 0.3s ease;
}

.sort-controls select:hover {
border-color: #6c757d;
}

table {
width: 100%;
border-collapse: separate;
border-spacing: 0;
margin-top: 15px;
font-size: 14px;
background-color: white;
border-radius: 12px;
overflow: hidden;
box-shadow: 0 4px 15px rgba(0, 0, 0, 0.08);
border: 1px solid #dee2e6;
}

th, td {
padding: 18px 16px;
text-align: left;
border-bottom: 1px solid #e9ecef;
word-break: keep-all;
white-space: nowrap;
}

th {
background: linear-gradient(135deg, #495057 0%, #343a40 100%);
font-weight: 800;
color: white;
font-size: 14px;
letter-spacing: 0.3px;
text-align: center;
vertical-align: middle;
border-right: 1px solid rgba(255, 255, 255, 0.1);
}

th:last-child {
border-right: none;
}

td {
font-size: 14px;
color: #212529;
vertical-align: middle;
}

tbody tr {
transition: all 0.2s ease;
}

tbody tr:hover {
background-color: #f8f9fa;
}

tbody tr:nth-child(even) {
background-color: #fafbfc;
}

tbody tr:nth-child(even):hover {
background-color: #f1f3f5;
}

.price-value {
color: #dc3545;
font-weight: 800;
font-size: 15px;
text-align: right;
}

.no-results {
text-align: center;
padding: 40px 20px;
color: #666;
font-size: 16px;
background: #f8f9fa;
border-radius: 12px;
margin: 20px 0;
border: 1px solid #dee2e6;
}

.loading {
text-align: center;
padding: 30px;
display: none;
font-size: 18px;
color: #6c757d;
font-weight: 600;
animation: pulse 1.5s ease-in-out infinite;
}

@keyframes pulse {
0%, 100% {
opacity: 1;
}
50% {
opacity: 0.5;
}
}

.status-message {
text-align: center;
padding: 14px 20px;
margin: 12px 0;
border-radius: 8px;
font-size: 14px;
font-weight: 500;
box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
animation: slideIn 0.3s ease;
}

@keyframes slideIn {
from {
opacity: 0;
transform: translateY(-10px);
}
to {
opacity: 1;
transform: translateY(0);
}
}

.success {
background: linear-gradient(135deg, #d4edda 0%, #c3e6cb 100%);
color: #155724;
border-left: 4px solid #28a745;
}

.error {
background: linear-gradient(135deg, #f8d7da 0%, #f5c6cb 100%);
color: #721c24;
border-left: 4px solid #dc3545;
}

.info {
background: linear-gradient(135deg, #d1ecf1 0%, #bee5eb 100%);
color: #0c5460;
border-left: 4px solid #17a2b8;
}

/* í•©ê³„ í–‰ ìŠ¤íƒ€ì¼ */
.total-row {
background: #f8f9fa !important;
font-weight: 700;
border-top: 3px solid #6c757d;
box-shadow: 0 -2px 10px rgba(108, 117, 125, 0.1);
}

.total-label {
text-align: right;
color: #2c3e50;
font-size: 16px;
text-transform: uppercase;
letter-spacing: 0.5px;
}

.total-amount {
color: #dc3545;
font-weight: 700;
font-size: 18px;
}

/* ëª¨ë°”ì¼ ìµœì í™” */
@media screen and (max-width: 768px) {
body {
padding: 12px;
}

.container {
padding: 15px;
}

h1 {
font-size: 24px;
margin-bottom: 20px;
}

.tabs {
gap: 8px;
flex-wrap: wrap;
}

.tab {
padding: 12px 24px;
font-size: 14px;
flex: 1;
min-width: 120px;
}

.search-form {
grid-template-columns: 1fr;
padding: 20px;
gap: 15px;
}

.common-upload-section {
padding: 15px;
}

.upload-area {
padding: 25px 15px;
min-height: 120px;
}

.upload-area i {
font-size: 40px;
}

.upload-area h3 {
font-size: 16px;
}

.results h2 {
font-size: 18px;
}

table {
font-size: 13px;
}

table thead {
display: none;
}

table, table tbody, table tr, table td {
display: block;
width: 100%;
}

table tr {
margin-bottom: 20px;
border: none;
border-radius: 12px;
padding: 18px;
background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);
box-shadow: 0 4px 12px rgba(0,0,0,0.1);
}

table tr:hover {
background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
transform: none;
}

table td {
padding: 12px 0;
text-align: left;
border-bottom: 1px solid #e9ecef;
display: block;
white-space: normal;
word-break: break-word;
font-weight: 500;
}

table td:last-child {
border-bottom: none;
padding-bottom: 0;
}

table td:before {
content: attr(data-label) " : ";
display: inline-block;
font-weight: 700;
color: #6c757d;
min-width: 100px;
margin-right: 8px;
}

.total-row {
margin-top: 20px;
background: #f8f9fa;
border: 3px solid #6c757d;
border-radius: 12px;
padding: 20px;
text-align: center;
box-shadow: 0 4px 15px rgba(108, 117, 125, 0.15);
}

.total-row td {
text-align: center !important;
border: none;
font-size: 16px;
display: block;
padding: 0;
}

.total-row td:before {
content: none !important;
}

.total-label {
color: #2c3e50;
font-size: 16px;
font-weight: 700;
margin-bottom: 0;
display: inline !important;
text-transform: uppercase;
letter-spacing: 0.5px;
}

.total-amount {
color: #dc3545;
font-size: 22px;
font-weight: 700;
display: inline !important;
margin-left: 8px;
}

.mobile-total-container {
display: flex;
justify-content: center;
align-items: center;
flex-wrap: nowrap;
gap: 10px;
}

.mobile-total-text {
color: #2c3e50;
font-size: 16px;
font-weight: 700;
white-space: nowrap;
text-transform: uppercase;
letter-spacing: 0.5px;
}

.mobile-total-amount {
color: #dc3545;
font-size: 22px;
font-weight: 700;
white-space: nowrap;
}
}
</style>
</head>
<body>
<div class="container">
<h1>PRICE_LIST</h1>

<!-- ê³µí†µ ì—…ë¡œë“œ ì„¹ì…˜ (í•œ ë²ˆë§Œ ì—…ë¡œë“œ) -->
<div class="common-upload-section">
<div class="upload-area" id="uploadArea">
<div>
<i>ğŸ“</i>
<h3>SQLite ë°ì´í„°ë² ì´ìŠ¤ íŒŒì¼ ì—…ë¡œë“œ</h3>
<p>í´ë¦­í•˜ê±°ë‚˜ íŒŒì¼ì„ ë“œë˜ê·¸í•˜ì—¬ ì—…ë¡œë“œí•˜ì„¸ìš”</p>
<p class="file-info">ì§€ì› í˜•ì‹: .db, .sqlite, .sqlite3 (ë‘ íƒ­ ëª¨ë‘ ì‚¬ìš© ê°€ëŠ¥)</p>
</div>
<input type="file" id="fileInput" class="file-input" accept=".db,.sqlite,.sqlite3">
</div>
<div id="statusMessage"></div>
<div id="dbInfo" class="db-info"></div>
</div>

<!-- íƒ­ ë©”ë‰´ -->
<div class="tabs">
<button class="tab active" onclick="switchTab('essa')">ESSA</button>
<button class="tab" onclick="switchTab('ace')">ACE</button>
</div>

<!-- ESSA íƒ­ ë‚´ìš© -->
<div id="essa-tab" class="tab-content active">
<div class="search-form" id="searchForm-essa">
<div class="form-group">
<label for="essa_p_name">ìƒí’ˆëª…</label>
<div class="field-note">ì„ íƒì‹œ ë‹¤ë¥¸ ì˜µì…˜ë“¤ì´ í•„í„°ë§ë¨</div>
<select id="essa_p_name" onchange="updateEssaDependentOptions('p_name')">
<option value="">ì „ì²´</option>
</select>
</div>

<div class="form-group">
<label for="essa_size">ì‚¬ì´ì¦ˆ</label>
<div class="field-note">ìƒí’ˆëª… ì„ íƒì‹œ í•´ë‹¹ ì‚¬ì´ì¦ˆë§Œ í‘œì‹œ</div>
<select id="essa_size" onchange="updateEssaDependentOptions('size')">
<option value="">ì „ì²´</option>
</select>
</div>

<div class="form-group">
<label for="essa_size_option">ì‚¬ì´ì¦ˆ ì˜µì…˜</label>
<div class="field-note">ìƒí’ˆëª… ì„ íƒì‹œ í•´ë‹¹ ì˜µì…˜ë§Œ í‘œì‹œ</div>
<select id="essa_size_option">
<option value="">ì „ì²´</option>
</select>
</div>

<div class="form-group">
<label for="essa_material">ì†Œì¬</label>
<div class="field-note">ìƒí’ˆëª… ì„ íƒì‹œ í•´ë‹¹ ì†Œì¬ë§Œ í‘œì‹œ</div>
<select id="essa_material" onchange="updateEssaDependentOptions('material')">
<option value="">ì „ì²´</option>
</select>
</div>

<div class="form-group">
<label for="essa_fabric">ì›ë‹¨</label>
<div class="field-note">ì†Œì¬ ì„ íƒì‹œ í•´ë‹¹ ì›ë‹¨ë§Œ í‘œì‹œ</div>
<select id="essa_fabric">
<option value="">ì „ì²´</option>
</select>
</div>

<div class="form-group">
<label for="essa_function">ê¸°ëŠ¥</label>
<div class="field-note">ìƒí’ˆëª… ì„ íƒì‹œ í•´ë‹¹ ê¸°ëŠ¥ë§Œ í‘œì‹œ</div>
<select id="essa_function">
<option value="">ì „ì²´</option>
</select>
</div>

<div class="form-group">
<label for="essa_stool">ìŠ¤íˆ´ í¬í•¨</label>
<div class="field-note">ìƒí’ˆëª… ì„ íƒì‹œ í•´ë‹¹ ì˜µì…˜ë§Œ í‘œì‹œ</div>
<select id="essa_stool">
<option value="">ì „ì²´</option>
</select>
</div>

<div class="form-group">
<label for="essa_style">ìŠ¤íƒ€ì¼</label>
<div class="field-note">ìƒí’ˆëª… ì„ íƒì‹œ í•´ë‹¹ ìŠ¤íƒ€ì¼ë§Œ í‘œì‹œ</div>
<select id="essa_style">
<option value="">ì „ì²´</option>
</select>
</div>

<div class="form-group">
<label for="essa_leather_option">ê°€ì£½ ì˜µì…˜</label>
<div class="field-note">ìƒí’ˆëª… ì„ íƒì‹œ í•´ë‹¹ ì˜µì…˜ë§Œ í‘œì‹œ</div>
<select id="essa_leather_option">
<option value="">ì „ì²´</option>
</select>
</div>

<div class="form-group">
<label for="essa_event_product">í–‰ì‚¬ ì œí’ˆ</label>
<div class="field-note">ìƒí’ˆëª… ì„ íƒì‹œ í•´ë‹¹ ì˜µì…˜ë§Œ í‘œì‹œ</div>
<select id="essa_event_product">
<option value="">ì „ì²´</option>
</select>
</div>

<div class="buttons">
<button onclick="searchProducts('essa')">ê²€ìƒ‰</button>
<button onclick="resetForm('essa')" class="reset-btn">ì´ˆê¸°í™”</button>
</div>
</div>

<div class="loading" id="loading-essa">ğŸ” ê²€ìƒ‰ ì¤‘ì…ë‹ˆë‹¤...</div>

<div class="results">
<h2>ê²€ìƒ‰ ê²°ê³¼</h2>
<div id="results-container-essa"></div>
</div>
</div>

<!-- ACE íƒ­ ë‚´ìš© -->
<div id="ace-tab" class="tab-content">
<div class="search-form" id="searchForm-ace">
<div class="form-group">
<label for="ace_frame">í”„ë ˆì„</label>
<div class="field-note">í”„ë ˆì„ ì„ íƒì‹œ í•´ë‹¹ íƒ€ì…/ì‚¬ì´ì¦ˆ í‘œì‹œ</div>
<select id="ace_frame" onchange="updateDependentOptions('ace')">
<option value="">ì „ì²´</option>
</select>
</div>

<div class="form-group">
<label for="ace_type">íƒ€ì…</label>
<div class="field-note">í”„ë ˆì„ ì„ íƒ ì‹œ ì—°ë™ë¨</div>
<select id="ace_type">
<option value="">ì „ì²´</option>
</select>
</div>

<div class="form-group">
<label for="ace_mattress">ë§¤íŠ¸ë¦¬ìŠ¤</label>
<div class="field-note">í”„ë ˆì„ ë¯¸ì„ íƒ ì‹œ ì‚¬ì´ì¦ˆì™€ ì—°ë™ë¨</div>
<select id="ace_mattress" onchange="updateDependentOptions('ace')">
<option value="">ì „ì²´</option>
</select>
</div>

<div class="form-group">
<label for="ace_size">ì‚¬ì´ì¦ˆ</label>
<div class="field-note">í”„ë ˆì„/ë§¤íŠ¸ë¦¬ìŠ¤ ì„ íƒ ì‹œ ì—°ë™ë¨</div>
<select id="ace_size">
<option value="">ì „ì²´</option>
</select>
</div>

<div class="form-group">
<label for="ace_foundation">íŒŒìš´ë°ì´ì…˜</label>
<div class="field-note">íŒŒìš´ë°ì´ì…˜ íƒ€ì… ì„ íƒ</div>
<select id="ace_foundation">
<option value="">ì „ì²´</option>
</select>
</div>

<div class="form-group">
<label for="ace_related_items">ì—°ê³„ í’ˆëª©</label>
<div class="field-note">í”„ë ˆì„/ë§¤íŠ¸ë¦¬ìŠ¤ì™€ ë…ë¦½ì </div>
<select id="ace_related_items">
<option value="">ì „ì²´</option>
</select>
</div>

<div class="form-group">
<label for="ace_nightstand">í˜‘íƒ</label>
<div class="field-note">ë°ì´í„°ë² ì´ìŠ¤ì—ì„œ ìë™ ë¡œë“œ</div>
<select id="ace_nightstand">
<option value="">ì „ì²´</option>
</select>
</div>

<div class="form-group">
<label for="ace_sideboard">ì‚¬ì´ë“œë³´ë“œ</label>
<div class="field-note">ë°ì´í„°ë² ì´ìŠ¤ì—ì„œ ìë™ ë¡œë“œ</div>
<select id="ace_sideboard">
<option value="">ì „ì²´</option>
</select>
</div>

<div class="form-group">
<label for="ace_furniture">ê°€êµ¬</label>
<div class="field-note">ë°ì´í„°ë² ì´ìŠ¤ì—ì„œ ìë™ ë¡œë“œ</div>
<select id="ace_furniture">
<option value="">ì „ì²´</option>
</select>
</div>

<div class="form-group">
<label for="ace_category">êµ¬ë¶„</label>
<div class="field-note">ë°ì´í„°ë² ì´ìŠ¤ì—ì„œ ìë™ ë¡œë“œ</div>
<select id="ace_category">
<option value="">ì „ì²´</option>
</select>
</div>

<div class="buttons">
<button onclick="searchProducts('ace')">ê²€ìƒ‰</button>
<button onclick="resetForm('ace')" class="reset-btn">ì´ˆê¸°í™”</button>
</div>
</div>

<div class="loading" id="loading-ace">ğŸ” ê²€ìƒ‰ ì¤‘ì…ë‹ˆë‹¤...</div>

<div class="results">
<h2>ê²€ìƒ‰ ê²°ê³¼</h2>
<div id="results-container-ace"></div>
</div>
</div>
</div>

<script>
const CONFIG = {
SQLJSCDN: 'https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.8.0',
ALLOWED_EXTENSIONS: /\.(db|sqlite|sqlite3)$/i,
FIELD_MAPPING: {
essa: {
p_name: ['P_NAME', 'ìƒí’ˆëª…', 'PRODUCT_NAME', 'NAME'],
size: ['SIZE', 'ì‚¬ì´ì¦ˆ'],
size_option: ['SIZE ì˜µì…˜', 'SIZE_OPTION', 'ì‚¬ì´ì¦ˆì˜µì…˜', 'ì‚¬ì´ì¦ˆ ì˜µì…˜', 'SIZEOPTION'],
material: ['MATERIAL', 'ì†Œì¬'],
fabric: ['FABRIC', 'ì›ë‹¨'],
function: ['FUNCTION', 'ê¸°ëŠ¥'],
stool: ['ìŠ¤íˆ´í¬í•¨', 'STOOL', 'ìŠ¤íˆ´', 'ìŠ¤íˆ´ í¬í•¨', 'STOOL í¬í•¨', 'STOOLí¬í•¨'],
style: ['STYLE', 'ìŠ¤íƒ€ì¼'],
leather_option: ['ê°€ì£½ì˜µì…˜', 'LEATHER_OPTION', 'ê°€ì£½ ì˜µì…˜', 'LEATHEROPTION'],
event_product: ['í–‰ì‚¬ì œí’ˆ', 'í–‰ì‚¬ ì œí’ˆ', 'EVENT_PRODUCT', 'EVENT', 'ì´ë²¤íŠ¸']
},
ace: {
frame: ['í”„ë ˆì„', 'FRAME', 'FRAME_TYPE', 'í”„ë ˆì„íƒ€ì…'],
type: ['íƒ€ì…', 'TYPE', 'TYPE_NM', 'BED_TYPE'],
mattress: ['ë§¤íŠ¸ë¦¬ìŠ¤', 'MATTRESS', 'MATTRESS_TYPE', 'ë§¤íŠ¸ë¦¬ìŠ¤íƒ€ì…'],
foundation: ['íŒŒìš´ë°ì´ì…˜', 'FOUNDATION', 'FOUNDATION_TYPE', 'íŒŒìš´ë°ì´ì…˜íƒ€ì…'],
size: ['SIZE', 'ì‚¬ì´ì¦ˆ', 'BED_SIZE'],
related_items: ['ì—°ê³„ í’ˆëª©', 'ì—°ê³„í’ˆëª©', 'RELATED_ITEMS', 'ì—°ê³„', 'RELATED_PRODUCTS', 'ì—°ê³„í’ˆëª©ì½”ë“œ', 'RELATED_ITEM_CODE'],
nightstand: ['í˜‘íƒ', 'NIGHTSTAND', 'í˜‘íƒí¬í•¨', 'NIGHTSTAND_YN'],
sideboard: ['ì‚¬ì´ë“œë³´ë“œ', 'SIDEBOARD', 'ì‚¬ì´ë“œë³´ë“œí¬í•¨', 'SIDEBOARD_YN'],
furniture: ['ê°€êµ¬', 'FURNITURE', 'FURNITURE_TYPE', 'ê°€êµ¬íƒ€ì…'],
category: ['êµ¬ë¶„', 'CATEGORY', 'CATEGORY_NM', 'ë¶„ë¥˜']
}
},
DISPLAY_COLUMNS: {
essa: [
{ keys: ['í’ˆëª©ì½”ë“œ', 'PRODUCT_CODE', 'CODE', 'ì½”ë“œ'], label: 'í’ˆëª©ì½”ë“œ' },
{ keys: ['ìƒí’ˆëª…', 'P_NAME', 'PRODUCT_NAME', 'NAME'], label: 'ìƒí’ˆëª…' },
{ keys: ['ì‚¬ì´ì¦ˆ', 'SIZE'], label: 'ì‚¬ì´ì¦ˆ' },
{ keys: ['íŒë§¤ê°€', 'PRICE', 'SALE_PRICE', 'ê°€ê²©', 'PRICE_AMOUNT'], label: 'íŒë§¤ê°€' },
{ keys: ['í–‰ì‚¬ì œí’ˆ', 'í–‰ì‚¬ ì œí’ˆ', 'EVENT_PRODUCT', 'EVENT', 'ì´ë²¤íŠ¸'], label: 'í–‰ì‚¬ì œí’ˆ' }
],
ace: [
{ keys: ['êµ¬ë¶„', 'CATEGORY', 'CATEGORY_NM', 'ë¶„ë¥˜'], label: 'êµ¬ë¶„' },
{ keys: ['ìƒí’ˆëª…', 'P_NAME', 'PRODUCT_NAME', 'NAME'], label: 'ìƒí’ˆëª…' },
{ keys: ['ì‚¬ì´ì¦ˆ', 'SIZE', 'BED_SIZE'], label: 'ì‚¬ì´ì¦ˆ' },
{ keys: ['ìƒ‰ìƒ', 'COLOR', 'COLOR_NM', 'ìƒ‰ìƒëª…'], label: 'ìƒ‰ìƒ' },
{ keys: ['íŒë§¤ê°€', 'PRICE', 'SALE_PRICE', 'ê°€ê²©', 'ê¸ˆì•¡', 'PRICE_AMOUNT', 'AMOUNT'], label: 'íŒë§¤ê°€' }
]
},
TABLE_CONFIG: {
essa: 'DATA',
ace: 'DATA_1'
}
};

// ê³µìœ  ë°ì´í„°ë² ì´ìŠ¤ ìƒíƒœ (í•œ ë²ˆë§Œ ë¡œë“œ)
const state = {
db: null,  // ê³µìœ  DB
fileName: '',
essa: { 
tableInfo: null, 
currentProducts: [], 
currentSort: 'none' 
},
ace: { 
tableInfo: null, 
currentProducts: [], 
currentSort: 'none', 
totalAmount: 0 
}
};

// íƒ­ ì „í™˜
function switchTab(tabName) {
document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
event.target.classList.add('active');
document.getElementById(`${tabName}-tab`).classList.add('active');
}

// ê³µí†µ ì—…ë¡œë“œ ì´ˆê¸°í™” (í•œ ë²ˆë§Œ)
function initUpload() {
const uploadArea = document.getElementById('uploadArea');
const fileInput = document.getElementById('fileInput');

uploadArea.addEventListener('click', () => fileInput.click());

uploadArea.addEventListener('dragover', (e) => {
e.preventDefault();
uploadArea.style.backgroundColor = '#f0f0f0';
});

uploadArea.addEventListener('dragleave', () => {
uploadArea.style.backgroundColor = '';
});

uploadArea.addEventListener('drop', (e) => {
e.preventDefault();
uploadArea.style.backgroundColor = '';
if (e.dataTransfer.files[0]) handleFileUpload(e.dataTransfer.files[0]);
});

fileInput.addEventListener('change', (e) => {
if (e.target.files[0]) handleFileUpload(e.target.files[0]);
});
}

function handleFileUpload(file) {
if (!CONFIG.ALLOWED_EXTENSIONS.test(file.name)) {
showStatus('SQLite ë°ì´í„°ë² ì´ìŠ¤ íŒŒì¼(.db, .sqlite, .sqlite3)ë§Œ ì—…ë¡œë“œ ê°€ëŠ¥í•©ë‹ˆë‹¤.', 'error');
return;
}

showStatus('íŒŒì¼ì„ ì½ëŠ” ì¤‘...', 'info');
const reader = new FileReader();
reader.onload = e => loadDatabase(e.target.result, file.name);
reader.onerror = () => showStatus('íŒŒì¼ ì½ê¸° ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.', 'error');
reader.readAsArrayBuffer(file);
}

async function loadDatabase(arrayBuffer, fileName) {
try {
showStatus('SQL.js ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ë¡œë“œ ì¤‘...', 'info');

if (typeof initSqlJs === 'undefined') {
await new Promise((resolve, reject) => {
const script = document.createElement('script');
script.src = `${CONFIG.SQLJSCDN}/sql-wasm.js`;
script.onload = resolve;
script.onerror = reject;
document.head.appendChild(script);
});
}

const SQL = await initSqlJs({
locateFile: file => `${CONFIG.SQLJSCDN}/${file}`
});

// ê³µìœ  DBì— ì €ì¥
state.db = new SQL.Database(new Uint8Array(arrayBuffer));
state.fileName = fileName;

// ë‘ íƒ­ ëª¨ë‘ ë¶„ì„
analyzeBothTables();

} catch (error) {
showStatus('ë°ì´í„°ë² ì´ìŠ¤ ë¡œë“œ ì‹¤íŒ¨: ' + error.message, 'error');
}
}

function analyzeBothTables() {
try {
let essaSuccess = false;
let aceSuccess = false;

// ESSA í…Œì´ë¸” ë¶„ì„
const essaTable = CONFIG.TABLE_CONFIG.essa;
const essaCheck = state.db.exec(`SELECT name FROM sqlite_master WHERE type='table' AND name='${essaTable}'`);
if (essaCheck.length && essaCheck[0].values.length) {
const essaColumns = state.db.exec(`PRAGMA table_info(${essaTable})`);
state.essa.tableInfo = {
name: essaTable,
columns: essaColumns[0].values.map(col => col[1])
};
const essaRowCount = state.db.exec(`SELECT COUNT(*) FROM ${essaTable}`);
const essaCount = essaRowCount[0].values[0][0];
populateAllEssaOptions();
document.getElementById('searchForm-essa').style.display = 'grid';
essaSuccess = true;
console.log(`ESSA í…Œì´ë¸” ë¡œë“œ ì™„ë£Œ: ${essaCount}ê°œ ë ˆì½”ë“œ`);
}

// ACE í…Œì´ë¸” ë¶„ì„
const aceTable = CONFIG.TABLE_CONFIG.ace;
const aceCheck = state.db.exec(`SELECT name FROM sqlite_master WHERE type='table' AND name='${aceTable}'`);
if (aceCheck.length && aceCheck[0].values.length) {
const aceColumns = state.db.exec(`PRAGMA table_info(${aceTable})`);
state.ace.tableInfo = {
name: aceTable,
columns: aceColumns[0].values.map(col => col[1])
};
const aceRowCount = state.db.exec(`SELECT COUNT(*) FROM ${aceTable}`);
const aceCount = aceRowCount[0].values[0][0];
populateAllOptions('ace');
document.getElementById('searchForm-ace').style.display = 'grid';
aceSuccess = true;
console.log(`ACE í…Œì´ë¸” ë¡œë“œ ì™„ë£Œ: ${aceCount}ê°œ ë ˆì½”ë“œ`);
}

// ê²°ê³¼ ë©”ì‹œì§€
if (essaSuccess && aceSuccess) {
showStatus(`"${state.fileName}" ë¡œë“œ ì™„ë£Œ! ESSAì™€ ACE íƒ­ ëª¨ë‘ ì‚¬ìš© ê°€ëŠ¥í•©ë‹ˆë‹¤.`, 'success');
displayDatabaseInfo();
} else if (essaSuccess) {
showStatus(`"${state.fileName}" ë¡œë“œ ì™„ë£Œ! ESSA íƒ­ë§Œ ì‚¬ìš© ê°€ëŠ¥í•©ë‹ˆë‹¤.`, 'success');
displayDatabaseInfo();
} else if (aceSuccess) {
showStatus(`"${state.fileName}" ë¡œë“œ ì™„ë£Œ! ACE íƒ­ë§Œ ì‚¬ìš© ê°€ëŠ¥í•©ë‹ˆë‹¤.`, 'success');
displayDatabaseInfo();
} else {
showStatus('ë°ì´í„°ë² ì´ìŠ¤ì— DATA ë˜ëŠ” DATA_1 í…Œì´ë¸”ì´ ì—†ìŠµë‹ˆë‹¤.', 'error');
}

} catch (error) {
showStatus('ë°ì´í„°ë² ì´ìŠ¤ ë¶„ì„ ì˜¤ë¥˜: ' + error.message, 'error');
}
}

function displayDatabaseInfo() {
let infoHTML = '<h4>ë°ì´í„°ë² ì´ìŠ¤ ì •ë³´</h4>';
infoHTML += `<p>íŒŒì¼ëª…: ${state.fileName}</p>`;
if (state.essa.tableInfo) {
const essaCount = state.db.exec(`SELECT COUNT(*) FROM ${state.essa.tableInfo.name}`);
infoHTML += `<p>ESSA í…Œì´ë¸”: ${state.essa.tableInfo.name} (${essaCount[0].values[0][0]}ê°œ ë ˆì½”ë“œ)</p>`;
}
if (state.ace.tableInfo) {
const aceCount = state.db.exec(`SELECT COUNT(*) FROM ${state.ace.tableInfo.name}`);
infoHTML += `<p>ACE í…Œì´ë¸”: ${state.ace.tableInfo.name} (${aceCount[0].values[0][0]}ê°œ ë ˆì½”ë“œ)</p>`;
}
document.getElementById('dbInfo').innerHTML = infoHTML;
document.getElementById('dbInfo').style.display = 'block';
}

function showStatus(message, type) {
document.getElementById('statusMessage').innerHTML = 
`<div class="status-message ${type}">${message}</div>`;
}

// ê²€ìƒ‰ í•¨ìˆ˜
function searchProducts(tabName) {
if (!state.db || !state[tabName].tableInfo) {
showStatus('ë¨¼ì € ë°ì´í„°ë² ì´ìŠ¤ íŒŒì¼ì„ ì—…ë¡œë“œí•´ì£¼ì„¸ìš”.', 'error');
return;
}

document.getElementById(`loading-${tabName}`).style.display = 'block';
document.getElementById(`results-container-${tabName}`).innerHTML = '';

setTimeout(() => {
try {
const searchParams = {};
const fieldMapping = CONFIG.FIELD_MAPPING[tabName];
Object.keys(fieldMapping).forEach(key => {
const value = document.getElementById(`${tabName}_${key}`).value;
if (value) searchParams[key] = value;
});

const products = performSearch(searchParams, tabName);
state[tabName].currentProducts = products;
state[tabName].currentSort = 'none';
displayResults(products, tabName);
} catch (error) {
document.getElementById(`results-container-${tabName}`).innerHTML = 
`<div class="no-results">ê²€ìƒ‰ ì¤‘ ì˜¤ë¥˜: ${error.message}</div>`;
} finally {
document.getElementById(`loading-${tabName}`).style.display = 'none';
}
}, 100);
}

function performSearch(searchParams, tabName) {
let query = `SELECT * FROM ${state[tabName].tableInfo.name} WHERE 1=1`;
const params = [];

if (tabName === 'essa') {
Object.entries(searchParams).forEach(([key, value]) => {
const matchedCol = findMatchingColumn(key, tabName);
if (matchedCol) {
const actualCol = getActualColumnName(matchedCol, tabName);
const safeCol = getSafeColumnName(actualCol);
query += ` AND ${safeCol} = ?`;
params.push(value);
}
});
} else if (tabName === 'ace') {
const frameValue = searchParams.frame;
const typeValue = searchParams.type;
const mattressValue = searchParams.mattress;
const foundationValue = searchParams.foundation;
const relatedItemsValue = searchParams.related_items;
const categoryValue = searchParams.category;
const sizeValue = searchParams.size;
const nightstandValue = searchParams.nightstand;
const sideboardValue = searchParams.sideboard;
const furnitureValue = searchParams.furniture;

let complexCondition = '';
let complexParams = [];

let group1Conditions = [];
let group1Params = [];

if (frameValue && typeValue) {
const frameCol = findMatchingColumn('frame', tabName);
const typeCol = findMatchingColumn('type', tabName);
if (frameCol && typeCol) {
const actualFrameCol = getActualColumnName(frameCol, tabName);
const actualTypeCol = getActualColumnName(typeCol, tabName);
const safeFrameCol = getSafeColumnName(actualFrameCol);
const safeTypeCol = getSafeColumnName(actualTypeCol);
group1Conditions.push(`(${safeFrameCol} = ? AND ${safeTypeCol} = ?)`);
group1Params.push(frameValue, typeValue);
}
} else if (frameValue) {
const frameCol = findMatchingColumn('frame', tabName);
if (frameCol) {
const actualFrameCol = getActualColumnName(frameCol, tabName);
const safeFrameCol = getSafeColumnName(actualFrameCol);
group1Conditions.push(`(${safeFrameCol} = ?)`);
group1Params.push(frameValue);
}
}

if (mattressValue) {
const mattressCol = findMatchingColumn('mattress', tabName);
if (mattressCol) {
const actualMattressCol = getActualColumnName(mattressCol, tabName);
const safeMattressCol = getSafeColumnName(actualMattressCol);
group1Conditions.push(`(${safeMattressCol} = ?)`);
group1Params.push(mattressValue);
}
}

if (foundationValue) {
const foundationCol = findMatchingColumn('foundation', tabName);
if (foundationCol) {
const actualFoundationCol = getActualColumnName(foundationCol, tabName);
const safeFoundationCol = getSafeColumnName(actualFoundationCol);
group1Conditions.push(`(${safeFoundationCol} = ?)`);
group1Params.push(foundationValue);
}
}

if (relatedItemsValue) {
const relatedItemsCol = findMatchingColumn('related_items', tabName);
if (relatedItemsCol) {
const actualRelatedItemsCol = getActualColumnName(relatedItemsCol, tabName);
const safeRelatedItemsCol = getSafeColumnName(actualRelatedItemsCol);
group1Conditions.push(`(${safeRelatedItemsCol} = ?)`);
group1Params.push(relatedItemsValue);
}
}

if (categoryValue) {
const categoryCol = findMatchingColumn('category', tabName);
if (categoryCol) {
const actualCategoryCol = getActualColumnName(categoryCol, tabName);
const safeCategoryCol = getSafeColumnName(actualCategoryCol);
group1Conditions.push(`(${safeCategoryCol} = ?)`);
group1Params.push(categoryValue);
}
}

if (group1Conditions.length > 0) {
let group1Query = '';
if (group1Conditions.length === 1) {
group1Query = group1Conditions[0];
} else {
group1Query = `(${group1Conditions.join(' OR ')})`;
}

if (sizeValue) {
const sizeCol = findMatchingColumn('size', tabName);
if (sizeCol) {
const actualSizeCol = getActualColumnName(sizeCol, tabName);
const safeSizeCol = getSafeColumnName(actualSizeCol);
group1Query = `(${group1Query} AND ${safeSizeCol} = ?)`;
group1Params.push(sizeValue);
}
}

complexCondition = group1Query;
complexParams = group1Params;
}

let group2Conditions = [];
let group2Params = [];

if (nightstandValue) {
const nightstandCol = findMatchingColumn('nightstand', tabName);
if (nightstandCol) {
const actualNightstandCol = getActualColumnName(nightstandCol, tabName);
const safeNightstandCol = getSafeColumnName(actualNightstandCol);
group2Conditions.push(`(${safeNightstandCol} = ?)`);
group2Params.push(nightstandValue);
}
}

if (sideboardValue) {
const sideboardCol = findMatchingColumn('sideboard', tabName);
if (sideboardCol) {
const actualSideboardCol = getActualColumnName(sideboardCol, tabName);
const safeSideboardCol = getSafeColumnName(actualSideboardCol);
group2Conditions.push(`(${safeSideboardCol} = ?)`);
group2Params.push(sideboardValue);
}
}

if (furnitureValue) {
const furnitureCol = findMatchingColumn('furniture', tabName);
if (furnitureCol) {
const actualFurnitureCol = getActualColumnName(furnitureCol, tabName);
const safeFurnitureCol = getSafeColumnName(actualFurnitureCol);
group2Conditions.push(`(${safeFurnitureCol} = ?)`);
group2Params.push(furnitureValue);
}
}

if (group2Conditions.length > 0) {
let group2Query = '';
if (group2Conditions.length === 1) {
group2Query = group2Conditions[0];
} else {
group2Query = `(${group2Conditions.join(' OR ')})`;
}

if (complexCondition) {
complexCondition = `(${complexCondition} OR ${group2Query})`;
complexParams = [...complexParams, ...group2Params];
} else {
complexCondition = group2Query;
complexParams = group2Params;
}
}

if (complexCondition) {
query += ` AND ${complexCondition}`;
params.push(...complexParams);
}
}

try {
const stmt = state.db.prepare(query);
stmt.bind(params);
const products = [];
let totalAmount = 0;

while (stmt.step()) {
const product = stmt.getAsObject();
products.push(product);

if (tabName === 'ace') {
const price = getPriceValue(product);
totalAmount += price;
}
}
stmt.free();

if (tabName === 'ace') {
state.ace.totalAmount = totalAmount;
}

return products;
} catch (error) {
console.error('Search query error:', error, query, params);
return [];
}
}

// ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜ë“¤
function findMatchingColumn(fieldKey, tabName) {
const fieldMapping = CONFIG.FIELD_MAPPING[tabName];
if (!fieldMapping[fieldKey]) {
return null;
}

const possibleNames = fieldMapping[fieldKey];
let matched = possibleNames.find(name => 
state[tabName].tableInfo.columns.some(col => col.toUpperCase() === name.toUpperCase())
);

if (!matched && fieldKey === 'size') {
matched = state[tabName].tableInfo.columns.find(col => 
col.toUpperCase().includes('SIZE') || col.includes('ì‚¬ì´ì¦ˆ')
);
}

return matched;
}

function getActualColumnName(matchedCol, tabName) {
const actual = state[tabName].tableInfo.columns.find(col => 
col.toUpperCase() === matchedCol.toUpperCase()
);

if (!actual) {
return state[tabName].tableInfo.columns.find(col => 
col.includes(matchedCol) || matchedCol.includes(col)
) || matchedCol;
}

return actual;
}

function getSafeColumnName(colName) {
return /[ -]/.test(colName) ? `[${colName}]` : colName;
}

function getPriceValue(product) {
const priceKeys = ['ê¸ˆì•¡', 'íŒë§¤ê°€', 'PRICE', 'SALE_PRICE', 'ê°€ê²©', 'PRICE_AMOUNT', 'AMOUNT'];
for (const key of priceKeys) {
const foundKey = Object.keys(product).find(k => k.toUpperCase() === key.toUpperCase());
if (foundKey) {
const value = product[foundKey];
if (value === undefined || value === null || value === '') {
continue;
}

let num;
if (typeof value === 'string') {
const cleanValue = value.replace(/[â‚©,ì›\\s]/g, '');
num = parseInt(cleanValue);
} else if (typeof value === 'number') {
num = value;
} else {
continue;
}

if (!isNaN(num) && num !== 0) {
return num;
}
}
}
return 0;
}

function formatPrice(price) {
if (!price) return "0";
const num = typeof price === 'string' ? parseInt(price.replace(/,/g, '')) : price;
return isNaN(num) ? "0" : num.toLocaleString('ko-KR');
}

function findColumnValue(product, possibleKeys) {
for (const key of possibleKeys) {
const foundKey = Object.keys(product).find(k => k.toUpperCase() === key.toUpperCase());
if (foundKey && product[foundKey] !== undefined && product[foundKey] !== null) {
return product[foundKey];
}
}
return '-';
}

function normalizeSizeValue(size) {
if (!size) return null;
let normalized = size.toString().trim();

if (normalized.match(/^\d+\s*(ì¸|äºº|IN)$/i)) {
const num = normalized.match(/^\d+/)[0];
return `${num}ì¸`;
}

if (normalized.match(/^[A-Z]{1,3}$/i)) {
return normalized.toUpperCase();
}

return normalized;
}

function compareSizeValues(a, b) {
const numA = a.match(/\d+/)?.[0] || 0;
const numB = b.match(/\d+/)?.[0] || 0;

if (numA !== numB) {
return parseInt(numA) - parseInt(numB);
}

return a.localeCompare(b);
}

// ESSA ì˜µì…˜ ì±„ìš°ê¸° í•¨ìˆ˜ë“¤
function populateAllEssaOptions() {
const fieldMapping = CONFIG.FIELD_MAPPING.essa;
Object.keys(fieldMapping).forEach(fieldKey => {
const matchedCol = findMatchingColumn(fieldKey, 'essa');
if (matchedCol) {
const actualCol = getActualColumnName(matchedCol, 'essa');
const safeCol = getSafeColumnName(actualCol);

try {
const query = `SELECT DISTINCT ${safeCol} FROM ${state.essa.tableInfo.name} 
WHERE ${safeCol} IS NOT NULL AND TRIM(${safeCol}) != '' 
ORDER BY ${safeCol}`;
const result = state.db.exec(query);

const selectElement = document.getElementById(`essa_${fieldKey}`);
selectElement.innerHTML = '<option value="">ì „ì²´</option>';

if (result.length > 0 && result[0].values.length > 0) {
const uniqueValues = [];
result[0].values.forEach(row => {
const value = row[0];
if (value && value.toString().trim() !== '') {
if (fieldKey === 'size') {
const normalized = normalizeSizeValue(value.toString().trim());
if (normalized) {
uniqueValues.push(normalized);
}
} else {
uniqueValues.push(value.toString().trim());
}
}
});

const sortedUniqueValues = [...new Set(uniqueValues)].sort((a, b) => {
if (fieldKey === 'size') {
return compareSizeValues(a, b);
}
return a.localeCompare(b);
});

sortedUniqueValues.forEach(value => {
const option = document.createElement('option');
option.value = value;
option.textContent = value;
selectElement.appendChild(option);
});
}
} catch (error) {
console.error(`Error populating essa ${fieldKey}:`, error);
}
}
});
}

function updateEssaDependentOptions(changedField) {
if (!state.db || !state.essa.tableInfo) return;

const pNameValue = document.getElementById('essa_p_name').value;
const sizeValue = document.getElementById('essa_size').value;
const materialValue = document.getElementById('essa_material').value;

if (pNameValue) {
updateEssaOptionsByProductName(pNameValue, sizeValue, materialValue, changedField);
} else if (sizeValue) {
updateEssaOptionsBySize(sizeValue, materialValue, changedField);
} else if (materialValue) {
updateEssaOptionsByMaterial(materialValue, changedField);
} else {
resetEssaDependentOptions();
}
}

function updateEssaOptionsByProductName(productName, currentSize, currentMaterial, changedField) {
const pNameCol = findMatchingColumn('p_name', 'essa');
if (!pNameCol) return;

const actualPNameCol = getActualColumnName(pNameCol, 'essa');
const safePNameCol = getSafeColumnName(actualPNameCol);

const dependentFields = ['size', 'size_option', 'material', 'fabric', 'function', 'stool', 'style', 'leather_option', 'event_product'];

dependentFields.forEach(fieldKey => {
if (changedField === fieldKey && (fieldKey === 'size' || fieldKey === 'material')) {
return;
}

const fieldCol = findMatchingColumn(fieldKey, 'essa');
if (!fieldCol) return;

const actualFieldCol = getActualColumnName(fieldCol, 'essa');
const safeFieldCol = getSafeColumnName(actualFieldCol);

try {
let whereClause = `${safePNameCol} = ?`;
const params = [productName];

if (fieldKey !== 'size' && currentSize) {
const sizeCol = findMatchingColumn('size', 'essa');
if (sizeCol) {
const actualSizeCol = getActualColumnName(sizeCol, 'essa');
const safeSizeCol = getSafeColumnName(actualSizeCol);
whereClause += ` AND ${safeSizeCol} = ?`;
params.push(currentSize);
}
}

if (fieldKey === 'fabric' && currentMaterial) {
const materialCol = findMatchingColumn('material', 'essa');
if (materialCol) {
const actualMaterialCol = getActualColumnName(materialCol, 'essa');
const safeMaterialCol = getSafeColumnName(actualMaterialCol);
whereClause += ` AND ${safeMaterialCol} = ?`;
params.push(currentMaterial);
}
}

const query = `SELECT DISTINCT ${safeFieldCol} FROM ${state.essa.tableInfo.name} 
WHERE ${whereClause} AND ${safeFieldCol} IS NOT NULL AND TRIM(${safeFieldCol}) != '' 
ORDER BY ${safeFieldCol}`;
const result = state.db.exec(query, params);

const selectElement = document.getElementById(`essa_${fieldKey}`);
const currentValue = selectElement.value;

if (changedField !== fieldKey) {
selectElement.innerHTML = '<option value="">ì „ì²´</option>';
} else {
selectElement.innerHTML = '<option value="">ì „ì²´</option>';
}

if (result.length > 0 && result[0].values.length > 0) {
const uniqueValues = [];
result[0].values.forEach(row => {
const value = row[0];
if (value && value.toString().trim() !== '') {
if (fieldKey === 'size') {
const normalized = normalizeSizeValue(value.toString().trim());
if (normalized) {
uniqueValues.push(normalized);
}
} else {
uniqueValues.push(value.toString().trim());
}
}
});

const sortedUniqueValues = [...new Set(uniqueValues)].sort((a, b) => {
if (fieldKey === 'size') {
return compareSizeValues(a, b);
}
return a.localeCompare(b);
});

sortedUniqueValues.forEach(value => {
const option = document.createElement('option');
option.value = value;
option.textContent = value;
if (changedField !== fieldKey && value === currentValue) {
option.selected = true;
}
selectElement.appendChild(option);
});
}
} catch (error) {
console.error(`Error updating ${fieldKey}:`, error);
}
});
}

function updateEssaOptionsBySize(sizeValue, currentMaterial, changedField) {
const sizeCol = findMatchingColumn('size', 'essa');
if (!sizeCol) return;

const actualSizeCol = getActualColumnName(sizeCol, 'essa');
const safeSizeCol = getSafeColumnName(actualSizeCol);

const dependentFields = ['p_name', 'size_option', 'material', 'fabric', 'function', 'stool', 'style', 'leather_option', 'event_product'];

dependentFields.forEach(fieldKey => {
if (changedField === fieldKey) return;

const fieldCol = findMatchingColumn(fieldKey, 'essa');
if (!fieldCol) return;

const actualFieldCol = getActualColumnName(fieldCol, 'essa');
const safeFieldCol = getSafeColumnName(actualFieldCol);

try {
let whereClause = `${safeSizeCol} = ?`;
const params = [sizeValue];

if (fieldKey === 'fabric' && currentMaterial) {
const materialCol = findMatchingColumn('material', 'essa');
if (materialCol) {
const actualMaterialCol = getActualColumnName(materialCol, 'essa');
const safeMaterialCol = getSafeColumnName(actualMaterialCol);
whereClause += ` AND ${safeMaterialCol} = ?`;
params.push(currentMaterial);
}
}

const query = `SELECT DISTINCT ${safeFieldCol} FROM ${state.essa.tableInfo.name} 
WHERE ${whereClause} AND ${safeFieldCol} IS NOT NULL AND TRIM(${safeFieldCol}) != '' 
ORDER BY ${safeFieldCol}`;
const result = state.db.exec(query, params);

const selectElement = document.getElementById(`essa_${fieldKey}`);
const currentValue = selectElement.value;
selectElement.innerHTML = '<option value="">ì „ì²´</option>';

if (result.length > 0 && result[0].values.length > 0) {
const uniqueValues = [];
result[0].values.forEach(row => {
const value = row[0];
if (value && value.toString().trim() !== '') {
uniqueValues.push(value.toString().trim());
}
});

const sortedUniqueValues = [...new Set(uniqueValues)].sort();

sortedUniqueValues.forEach(value => {
const option = document.createElement('option');
option.value = value;
option.textContent = value;
if (value === currentValue) {
option.selected = true;
}
selectElement.appendChild(option);
});
}
} catch (error) {
console.error(`Error updating ${fieldKey}:`, error);
}
});
}

function updateEssaOptionsByMaterial(materialValue, changedField) {
const materialCol = findMatchingColumn('material', 'essa');
if (!materialCol) return;

const actualMaterialCol = getActualColumnName(materialCol, 'essa');
const safeMaterialCol = getSafeColumnName(actualMaterialCol);

if (changedField !== 'fabric') {
const fabricCol = findMatchingColumn('fabric', 'essa');
if (fabricCol) {
const actualFabricCol = getActualColumnName(fabricCol, 'essa');
const safeFabricCol = getSafeColumnName(actualFabricCol);

try {
const query = `SELECT DISTINCT ${safeFabricCol} FROM ${state.essa.tableInfo.name} 
WHERE ${safeMaterialCol} = ? AND ${safeFabricCol} IS NOT NULL AND TRIM(${safeFabricCol}) != '' 
ORDER BY ${safeFabricCol}`;
const result = state.db.exec(query, [materialValue]);

const selectElement = document.getElementById('essa_fabric');
const currentValue = selectElement.value;
selectElement.innerHTML = '<option value="">ì „ì²´</option>';

if (result.length > 0 && result[0].values.length > 0) {
const uniqueValues = [];
result[0].values.forEach(row => {
const value = row[0];
if (value && value.toString().trim() !== '') {
uniqueValues.push(value.toString().trim());
}
});

const sortedUniqueValues = [...new Set(uniqueValues)].sort();

sortedUniqueValues.forEach(value => {
const option = document.createElement('option');
option.value = value;
option.textContent = value;
if (value === currentValue) {
option.selected = true;
}
selectElement.appendChild(option);
});
}
} catch (error) {
console.error('Error updating fabric:', error);
}
}
}
}

function resetEssaDependentOptions() {
const fields = ['p_name', 'size', 'size_option', 'material', 'fabric', 'function', 'stool', 'style', 'leather_option', 'event_product'];
fields.forEach(fieldKey => {
const selectElement = document.getElementById(`essa_${fieldKey}`);
selectElement.innerHTML = '<option value="">ì „ì²´</option>';
});

if (state.db && state.essa.tableInfo) {
populateAllEssaOptions();
}
}

// ACE ì˜µì…˜ ì±„ìš°ê¸° í•¨ìˆ˜ë“¤
function populateAllOptions(tabName) {
const fieldMapping = CONFIG.FIELD_MAPPING[tabName];
Object.keys(fieldMapping).forEach(fieldKey => {
if (fieldKey !== 'type' && fieldKey !== 'size') {
const matchedCol = findMatchingColumn(fieldKey, tabName);
if (matchedCol) {
const actualCol = getActualColumnName(matchedCol, tabName);
const safeCol = getSafeColumnName(actualCol);

try {
const query = `SELECT DISTINCT ${safeCol} FROM ${state[tabName].tableInfo.name} 
WHERE ${safeCol} IS NOT NULL AND ${safeCol} != '' 
ORDER BY ${safeCol}`;
const result = state.db.exec(query);

const selectElement = document.getElementById(`${tabName}_${fieldKey}`);
const currentValue = selectElement.value;
selectElement.innerHTML = '<option value="">ì „ì²´</option>';

if (result.length > 0 && result[0].values.length > 0) {
const uniqueValues = [];
result[0].values.forEach(row => {
const value = row[0];
if (value && value.toString().trim() !== '') {
uniqueValues.push(value.toString().trim());
}
});

const sortedUniqueValues = [...new Set(uniqueValues)].sort();

sortedUniqueValues.forEach(value => {
const option = document.createElement('option');
option.value = value;
option.textContent = value;
if (value === currentValue) {
option.selected = true;
}
selectElement.appendChild(option);
});
}
} catch (error) {
console.error(`Error populating ${fieldKey}:`, error);
}
}
}
});

populateSizeOptions(tabName);
}

function populateSizeOptions(tabName) {
const sizeSelect = document.getElementById(`${tabName}_size`);
sizeSelect.innerHTML = '<option value="">ì „ì²´</option>';

if (!state.db || !state[tabName].tableInfo) return;

const matchedCol = findMatchingColumn('size', tabName);
if (matchedCol) {
const actualCol = getActualColumnName(matchedCol, tabName);
const safeCol = getSafeColumnName(actualCol);

try {
const query = `SELECT DISTINCT ${safeCol} FROM ${state[tabName].tableInfo.name} 
WHERE ${safeCol} IS NOT NULL AND TRIM(${safeCol}) != '' 
ORDER BY ${safeCol}`;
const result = state.db.exec(query);

if (result.length > 0 && result[0].values.length > 0) {
const uniqueValues = [];
result[0].values.forEach(row => {
const value = row[0];
if (value && value.toString().trim() !== '') {
const normalized = normalizeSizeValue(value.toString().trim());
if (normalized) {
uniqueValues.push(normalized);
}
}
});

const sortedUniqueValues = [...new Set(uniqueValues)].sort(compareSizeValues);

sortedUniqueValues.forEach(value => {
const option = document.createElement('option');
option.value = value;
option.textContent = value;
sizeSelect.appendChild(option);
});
}
} catch (error) {
console.error(`Error populating size for ${tabName}:`, error);
}
}
}

function updateDependentOptions(tabName) {
if (!state.db || !state[tabName].tableInfo) return;

const frameValue = document.getElementById(`${tabName}_frame`).value;
const mattressValue = document.getElementById(`${tabName}_mattress`).value;

if (frameValue) {
updateTypeOptions(tabName, frameValue);
updateSizeOptionsByFrame(tabName, frameValue);
} else if (mattressValue) {
updateSizeOptionsByMattress(tabName, mattressValue);
} else {
resetDependentOptions(tabName);
}
}

function updateTypeOptions(tabName, frameValue) {
const frameCol = findMatchingColumn('frame', tabName);
const typeCol = findMatchingColumn('type', tabName);
if (!frameCol || !typeCol) return;

const actualFrameCol = getActualColumnName(frameCol, tabName);
const actualTypeCol = getActualColumnName(typeCol, tabName);
const safeFrameCol = getSafeColumnName(actualFrameCol);
const safeTypeCol = getSafeColumnName(actualTypeCol);

try {
const query = `SELECT DISTINCT ${safeTypeCol} FROM ${state[tabName].tableInfo.name} 
WHERE ${safeFrameCol} = ? AND ${safeTypeCol} IS NOT NULL AND ${safeTypeCol} != '' 
ORDER BY ${safeTypeCol}`;
const result = state.db.exec(query, [frameValue]);

const selectElement = document.getElementById(`${tabName}_type`);
const currentValue = selectElement.value;
selectElement.innerHTML = '<option value="">ì „ì²´</option>';

if (result.length > 0 && result[0].values.length > 0) {
const uniqueValues = [];
result[0].values.forEach(row => {
const value = row[0];
if (value && value.toString().trim() !== '') {
uniqueValues.push(value.toString().trim());
}
});

const sortedUniqueValues = [...new Set(uniqueValues)].sort();

sortedUniqueValues.forEach(value => {
const option = document.createElement('option');
option.value = value;
option.textContent = value;
if (value === currentValue) {
option.selected = true;
}
selectElement.appendChild(option);
});

const fieldNote = selectElement.parentNode.querySelector('.field-note');
if (fieldNote) {
fieldNote.textContent = `í”„ë ˆì„ ì„ íƒì‹œ í•´ë‹¹ íƒ€ì… í‘œì‹œ (${sortedUniqueValues.length}ê°œ)`;
}
} else {
const fieldNote = selectElement.parentNode.querySelector('.field-note');
if (fieldNote) {
fieldNote.textContent = 'í•´ë‹¹ í”„ë ˆì„ì— ë§ëŠ” íƒ€ì…ì´ ì—†ìŠµë‹ˆë‹¤';
}
}
} catch (error) {
console.error('Error updating type options:', error);
}
}

function updateSizeOptionsByFrame(tabName, frameValue) {
const frameCol = findMatchingColumn('frame', tabName);
const sizeCol = findMatchingColumn('size', tabName);
if (!frameCol || !sizeCol) return;

const actualFrameCol = getActualColumnName(frameCol, tabName);
const actualSizeCol = getActualColumnName(sizeCol, tabName);
const safeFrameCol = getSafeColumnName(actualFrameCol);
const safeSizeCol = getSafeColumnName(actualSizeCol);

try {
const query = `SELECT DISTINCT ${safeSizeCol} FROM ${state[tabName].tableInfo.name} 
WHERE ${safeFrameCol} = ? AND ${safeSizeCol} IS NOT NULL AND ${safeSizeCol} != '' 
ORDER BY ${safeSizeCol}`;
const result = state.db.exec(query, [frameValue]);

const selectElement = document.getElementById(`${tabName}_size`);
const currentValue = selectElement.value;
selectElement.innerHTML = '<option value="">ì „ì²´</option>';

if (result.length > 0 && result[0].values.length > 0) {
const uniqueValues = [];
result[0].values.forEach(row => {
const value = row[0];
if (value && value.toString().trim() !== '') {
uniqueValues.push(value.toString().trim());
}
});

const sortedUniqueValues = [...new Set(uniqueValues)].sort();

sortedUniqueValues.forEach(value => {
const option = document.createElement('option');
option.value = value;
option.textContent = value;
if (value === currentValue) {
option.selected = true;
}
selectElement.appendChild(option);
});

const fieldNote = selectElement.parentNode.querySelector('.field-note');
if (fieldNote) {
fieldNote.textContent = `í”„ë ˆì„ ì„ íƒì‹œ í•´ë‹¹ ì‚¬ì´ì¦ˆ í‘œì‹œ (${sortedUniqueValues.length}ê°œ)`;
}
} else {
const fieldNote = selectElement.parentNode.querySelector('.field-note');
if (fieldNote) {
fieldNote.textContent = 'í•´ë‹¹ í”„ë ˆì„ì— ë§ëŠ” ì‚¬ì´ì¦ˆê°€ ì—†ìŠµë‹ˆë‹¤';
}
}
} catch (error) {
console.error('Error updating size options by frame:', error);
}
}

function updateSizeOptionsByMattress(tabName, mattressValue) {
const mattressCol = findMatchingColumn('mattress', tabName);
const sizeCol = findMatchingColumn('size', tabName);
if (!mattressCol || !sizeCol) return;

const actualMattressCol = getActualColumnName(mattressCol, tabName);
const actualSizeCol = getActualColumnName(sizeCol, tabName);
const safeMattressCol = getSafeColumnName(actualMattressCol);
const safeSizeCol = getSafeColumnName(actualSizeCol);

try {
const query = `SELECT DISTINCT ${safeSizeCol} FROM ${state[tabName].tableInfo.name} 
WHERE ${safeMattressCol} = ? AND ${safeSizeCol} IS NOT NULL AND ${safeSizeCol} != '' 
ORDER BY ${safeSizeCol}`;
const result = state.db.exec(query, [mattressValue]);

const selectElement = document.getElementById(`${tabName}_size`);
const currentValue = selectElement.value;
selectElement.innerHTML = '<option value="">ì „ì²´</option>';

if (result.length > 0 && result[0].values.length > 0) {
const uniqueValues = [];
result[0].values.forEach(row => {
const value = row[0];
if (value && value.toString().trim() !== '') {
uniqueValues.push(value.toString().trim());
}
});

const sortedUniqueValues = [...new Set(uniqueValues)].sort();

sortedUniqueValues.forEach(value => {
const option = document.createElement('option');
option.value = value;
option.textContent = value;
if (value === currentValue) {
option.selected = true;
}
selectElement.appendChild(option);
});

const fieldNote = selectElement.parentNode.querySelector('.field-note');
if (fieldNote) {
fieldNote.textContent = `ë§¤íŠ¸ë¦¬ìŠ¤ ì„ íƒì‹œ í•´ë‹¹ ì‚¬ì´ì¦ˆ í‘œì‹œ (${sortedUniqueValues.length}ê°œ)`;
}
} else {
const fieldNote = selectElement.parentNode.querySelector('.field-note');
if (fieldNote) {
fieldNote.textContent = 'í•´ë‹¹ ë§¤íŠ¸ë¦¬ìŠ¤ì— ë§ëŠ” ì‚¬ì´ì¦ˆê°€ ì—†ìŠµë‹ˆë‹¤';
}
}
} catch (error) {
console.error('Error updating size options by mattress:', error);
}
}

function resetDependentOptions(tabName) {
const typeSelect = document.getElementById(`${tabName}_type`);
typeSelect.innerHTML = '<option value="">ì „ì²´</option>';
const typeFieldNote = typeSelect.parentNode.querySelector('.field-note');
if (typeFieldNote) {
typeFieldNote.textContent = 'í”„ë ˆì„ ì„ íƒ ì‹œ ì—°ë™ë¨';
}

const sizeSelect = document.getElementById(`${tabName}_size`);
sizeSelect.innerHTML = '<option value="">ì „ì²´</option>';
const sizeFieldNote = sizeSelect.parentNode.querySelector('.field-note');
if (sizeFieldNote) {
sizeFieldNote.textContent = 'í”„ë ˆì„/ë§¤íŠ¸ë¦¬ìŠ¤ ì„ íƒ ì‹œ ì—°ë™ë¨';
}

populateAllOptions(tabName);
}

// ê²°ê³¼ í‘œì‹œ í•¨ìˆ˜
function displayResults(products, tabName) {
if (products.length === 0) {
document.getElementById(`results-container-${tabName}`).innerHTML = 
'<div class="no-results">ê²€ìƒ‰ ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤.</div>';
return;
}

let sortHTML = `
<div class="sort-controls">
<label for="sortSelect-${tabName}">ì •ë ¬:</label>
<select id="sortSelect-${tabName}" onchange="handleSort(this.value, '${tabName}')">
<option value="none" ${state[tabName].currentSort === 'none' ? 'selected' : ''}>ê¸°ë³¸</option>
<option value="asc" ${state[tabName].currentSort === 'asc' ? 'selected' : ''}>ê°€ê²© ë‚®ì€ìˆœ</option>
<option value="desc" ${state[tabName].currentSort === 'desc' ? 'selected' : ''}>ê°€ê²© ë†’ì€ìˆœ</option>
</select>
</div>`;

const displayColumns = CONFIG.DISPLAY_COLUMNS[tabName];
let tableHTML = '<table><thead><tr>';

displayColumns.forEach(col => {
tableHTML += `<th>${col.label}</th>`;
});
tableHTML += '</tr></thead><tbody>';

products.forEach(product => {
tableHTML += '<tr>';
displayColumns.forEach(col => {
let value = findColumnValue(product, col.keys) || '-';
if (col.label === 'íŒë§¤ê°€') {
value = formatPrice(value) + 'ì›';
}
const priceClass = col.label === 'íŒë§¤ê°€' ? ' class="price-value"' : '';
tableHTML += `<td data-label="${col.label}"${priceClass}>${value}</td>`;
});
tableHTML += '</tr>';
});

if (tabName === 'ace' && products.length > 0) {
const totalAmount = state.ace.totalAmount;
const colCount = displayColumns.length;
const isMobile = window.innerWidth <= 768;

if (isMobile) {
tableHTML += `<tr class="total-row">`;
tableHTML += `<td colspan="${colCount}">`;
tableHTML += `<div class="mobile-total-container">`;
tableHTML += `<span class="mobile-total-text">ì´ í•©ê³„ :</span>`;
tableHTML += `<span class="mobile-total-amount">${formatPrice(totalAmount)}ì›</span>`;
tableHTML += `</div>`;
tableHTML += `</td>`;
tableHTML += `</tr>`;
} else {
tableHTML += `<tr class="total-row">`;
tableHTML += `<td colspan="${colCount - 1}" class="total-label">ì´ í•©ê³„</td>`;
tableHTML += `<td class="total-amount">${formatPrice(totalAmount)}ì›</td>`;
tableHTML += `</tr>`;
}
}

tableHTML += `</tbody></table>`;
tableHTML += `<div style="margin-top: 10px; color: #666; font-size: 14px; text-align: center;">`;
tableHTML += `ì´ ${products.length}ê°œì˜ ì œí’ˆì´ ê²€ìƒ‰ë˜ì—ˆìŠµë‹ˆë‹¤.</div>`;

document.getElementById(`results-container-${tabName}`).innerHTML = sortHTML + tableHTML;
}

function handleSort(sortType, tabName) {
if (state[tabName].currentProducts.length === 0) return;

state[tabName].currentSort = sortType;
let sortedProducts = [...state[tabName].currentProducts];

if (sortType === 'asc' || sortType === 'desc') {
sortedProducts.sort((a, b) => {
const priceA = getPriceValue(a);
const priceB = getPriceValue(b);
return sortType === 'asc' ? priceA - priceB : priceB - priceA;
});
}

displayResults(sortedProducts, tabName);
}

function resetForm(tabName) {
const fieldMapping = CONFIG.FIELD_MAPPING[tabName];
Object.keys(fieldMapping).forEach(key => {
document.getElementById(`${tabName}_${key}`).value = '';
});

document.getElementById(`results-container-${tabName}`).innerHTML = '';
state[tabName].currentProducts = [];
state[tabName].currentSort = 'none';

if (tabName === 'ace') {
state.ace.totalAmount = 0;
resetDependentOptions(tabName);
} else {
resetEssaDependentOptions();
}
}

// ì „ì—­ í•¨ìˆ˜ ë…¸ì¶œ
window.switchTab = switchTab;
window.searchProducts = searchProducts;
window.resetForm = resetForm;
window.handleSort = handleSort;
window.updateDependentOptions = updateDependentOptions;
window.updateEssaDependentOptions = updateEssaDependentOptions;

// ì´ˆê¸°í™”
initUpload();
</script>
</body>
</html>
